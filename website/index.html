<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Goblins HQ</title>
    <meta name="description" content="Controller for Goblins game">

    <style>
        body {
            background-image: "img/bg.png";
        }

        #canvas {
            border: 1px solid red;
        }
    </style>


</head>

<body>
    <div class="game-info">
        <button class="left">TODO: </button>
        <button class="right">TODO: view next player</button>
        <div class="player-stats"></div>
    </div>
    <div class="message">
        <label for="name">Send message to operative:</label>
        <input type="text"> </input>
        <button class="send">Send</button>
    </div>
    <canvas id="canvas" width=500 height=400></canvas>

    <!-- require ArcGIS REST JS libraries from https://unpkg.com -->
    <script src="https://unpkg.com/@esri/arcgis-rest-request@3.0.0/dist/umd/request.umd.js"></script>
  <script src="https://unpkg.com/@esri/arcgis-rest-auth@3.0.0/dist/umd/auth.umd.js"></script>
  <script src="https://unpkg.com/@esri/arcgis-rest-feature-layer@3.0.0/dist/umd/feature-layer.umd.js"></script>

    <script>

//------------------ REST TEST------------------ REST TEST------------------ REST TEST------------------ REST TEST------------------ REST TEST


    /* when including ArcGIS REST JS all exports are available
    from the same arcgisRest global */

    const apiKey = "AAPKb40cbeb34328430da59e394ca9aa1093cO3mnRFhUO_fclB1uhTEYLxEWvgVKHRtnMdO9ct1aMbj76IMGKQG8XErc4ul1zTd";
    const authentication = new arcgisRest.ApiKey({
      key: apiKey
    });

    const theUrl = "https://services1.arcgis.com/BteRGjYsGtVEXzaX/arcgis/rest/services/Friend_Information/FeatureServer/0";

    function queryFts () {
        arcgisRest.queryFeatures({
            url: theUrl,
            where: "friend_name = null",
            authentication
        })
        .then(response => {
            console.log("resp")
        //     console.log(response.features);

        // // delete the feature using the objectId of the updated feature
        // // NOTE: it is the same objectId provided in the response of `arcgisRest.addFeatures`
        //     const featureToDelete = [response.features];

        //     arcgisRest.deleteFeatures({
        //         url: theUrl,
        //         objectIds: [featureToDelete],
        //         authentication
        //     })
        //     .then(handleDeleted);
        })
    }

// const playing_gob = {
//       attributes: {
//         friend_name: 'ET',
//         pos_x: '2',
//         pos_y: '1'
//       },
//     };

//     queryFts();

//     // begin by adding a new feature to the feature service layer,
//     // then update its attributes,
//     // and finally delete it from the layer
//     arcgisRest.addFeatures({
//       url: theUrl,
//       features: [playing_gob],
//       authentication
//     })
//       .then(handleAdded);

//     function handleAdded(response) {
//       console.log(response);
//       queryFts();
      

//       if (!response.addResults[0].success) {
//         // stop early if adding a new feature was not successful
//         return;
//       }

//       // perform an update to feature attributes using the objectId of the newly added feature
//       const featureToUpdate = {
//         attributes: {
//           objectId: response.addResults[0].objectId,
//           name: 'Eddie',
//           pos_x: '2',
//           pos_y: '3'
//         }
//       };

//       arcgisRest.updateFeatures({
//         url: theUrl,
//         features: [featureToUpdate],
//         authentication
//       })
//         .then(handleUpdated);
//     }

//     function handleUpdated(response) {
//       console.log(response);
//       queryFts();

//       if (!response.updateResults[0].success) {
//         // stop early if updating the feature was not successful
//         return;
//       }

 

    function handleDeleted(response) {
      console.log(response);

      if (!response.deleteResults[0].success) {
        // stop early if updating the feature was not successful
        return;
      }
    }


//--------------------WORKING STUFF--------------------WORKING STUFF--------------------WORKING STUFF--------------------WORKING STUFF
        //todo: array of player objects, with these properties
        const currentPlayer = 1;
        const gameTime = " ?";
        const numFriends = "?";
        // for navigating between player objects
        const stats = document.querySelector(".player-stats");
        const sendButton = document.querySelector(".send");
        const input = document.querySelector("input");

        function sendMessage() {
            console.log(input.value);
        }

        sendButton.addEventListener('click', () => (console.log(input.value)));
        stats.innerHTML = `Goblin Operative ${currentPlayer}: ${numFriends} friends acquired, ${gameTime} seconds elapsed`;



        // get canvas related references
        const canvas = document.querySelector("canvas");
        const ctx = canvas.getContext("2d");
        const BB = canvas.getBoundingClientRect();
        const offsetX = BB.left;
        const offsetY = BB.top;
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        // drag related
        var dragok = false;
        var startX = 0;
        var startY = 0;



        // an array of objects that define different rectangles
        const gobs = [];
        gobs.push({
            x: 450,
            y: 25,
            width: 30,
            height: 30,
            fill: "#ffff00",
            canDrag: true,
            isDragging: false
        });
        gobs.push({
            x: 450,
            y: 100,
            width: 30,
            height: 30,
            fill: "#ffff00",
            canDrag: true,
            isDragging: false
        });
        gobs.push({
            x: 450,
            y: 175,
            width: 30,
            height: 30,
            fill: "#ffff00",
            canDrag: true,
            isDragging: false
        });
        gobs.push({
            x: 450,
            y: 250,
            width: 30,
            height: 30,
            fill: "#ffff00",
            canDrag: true,
            isDragging: false
        });

        // listen for mouse events
        canvas.onmousedown = myDown;
        canvas.onmouseup = myUp;
        canvas.onmousemove = myMove;


        // draw a single rect
        function rect(x, y, w, h) {
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.closePath();
            ctx.fill();
        }

        // clear the canvas
        function clear() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
        }

        // redraw the scene
        function draw() {
            clear();
            ctx.fillStyle = "#202020";
            rect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = "#808080";
            rect(400, 0, 100, HEIGHT);
            ctx.fillStyle = "#505050";
            rect(100-75, 250-25, 100, 200);
            rect(200-75, 350-25, 25, 50);
            rect (200-75, 350-25, 25, 30);
            rect (250-75, 300-25, 5, 15);
            rect(250-75, 250-25, 10, 25);
            rect(300-75, 350-25, 100, 25);
            rect (250-75, 100-25, 200, 100);
            rect (375-25, 50-25, 10, 50);
            rect (110, 50, 15, 150);
            ctx.fillStyle = "#FF0000";
            ctx.beginPath();
            ctx.arc(100, 75, 10, 0, 2 * Math.PI);
            ctx.fill();
            
            // redraw each rect in the rects[] array
            for (var i = 0; i < gobs.length; i++) {
                var r = gobs[i];
                ctx.fillStyle = r.fill;
                rect(r.x, r.y, r.width, r.height);
            }
        }


        // handle mousedown events
        function myDown(e) {

            // tell the browser we're handling this mouse event
            e.preventDefault();
            e.stopPropagation();

            // get the current mouse position
            var mx = parseInt(e.clientX - offsetX);
            var my = parseInt(e.clientY - offsetY);

            // test each rect to see if mouse is inside
            dragok = false;
            for (var i = 0; i < gobs.length; i++) {
                var r = gobs[i];
                if (mx > r.x && mx < r.x + r.width && my > r.y && my < r.y + r.height) {
                    if (r.canDrag) {
                    // if yes, set that rects isDragging=true
                    dragok = true;
                    r.isDragging = true;
                    }

                }
            }
            // save the current mouse position
            startX = mx;
            startY = my;
        }


        // handle mouseup events
        function myUp(e) {
            // tell the browser we're handling this mouse event
            e.preventDefault();
            e.stopPropagation();

            // clear all the dragging flags
            dragok = false;
            for (var i = 0; i < gobs.length; i++) {
                if (gobs[i].isDragging) {
                    gobs[i].isDragging = false;
                    if (gobs[i].x < 400)
                        gobs[i].canDrag = false;
                        console.log(`Final pos for goblin ${i}: ${gobs[i].x}, ${gobs[i].y}`)
                }
            }
        }


        // handle mouse moves
        function myMove(e) {
            // if we're dragging anything...
            if (dragok) {

                // tell the browser we're handling this mouse event
                e.preventDefault();
                e.stopPropagation();

                // get the current mouse position
                var mx = parseInt(e.clientX - offsetX);
                var my = parseInt(e.clientY - offsetY);

                // calculate the distance the mouse has moved
                // since the last mousemove
                var dx = mx - startX;
                var dy = my - startY;

                // move each rect that isDragging 
                // by the distance the mouse has moved
                // since the last mousemove
                for (var i = 0; i < gobs.length; i++) {
                    var r = gobs[i];
                    if (r.isDragging) {
                        r.x += dx;
                        r.y += dy;
                    }
                }

                // redraw the scene with the new rect positions
                draw();

                // reset the starting mouse position for the next mousemove
                startX = mx;
                startY = my;

            }
        }

                // call to draw the scene
                draw();

    </script>
</body>

</html>